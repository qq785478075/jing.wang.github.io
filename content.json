{"meta":{"title":"我的博客","subtitle":null,"description":"想想光头强，想想辉泰朗，在想想汤姆猫，我有什么理由放弃。","author":"王小瘦","url":"http://yoursite.com"},"pages":[{"title":"关于我","date":"2018-02-28T02:12:26.000Z","updated":"2020-07-03T02:59:28.102Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"QQ:785478075微信：wj_tq1314电话：18225380928"},{"title":"分类","date":"2018-02-28T02:09:13.000Z","updated":"2020-07-03T02:59:28.102Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-02-28T02:08:43.000Z","updated":"2020-07-03T02:59:28.104Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"小程序实现元素拖动效果","slug":"小程序实现元素拖动效果","date":"2020-07-06T06:03:05.000Z","updated":"2020-07-06T07:12:06.454Z","comments":false,"path":"小程序实现元素拖动效果/","link":"","permalink":"http://yoursite.com/小程序实现元素拖动效果/","excerpt":"实现客服按钮在页面区域可拖动功能;","text":"实现客服按钮在页面区域可拖动功能; 效果图如下： 具体操作： 首先要定义一个容器,使元素在这个容器范围内可来回拖动； 1234567&lt;movable-area class=\"contact_box\"&gt; &lt;movable-view class=\"contact_conten\" x=\"&#123;&#123;x&#125;&#125;\" y=\"&#123;&#123;y&#125;&#125;\" direction=\"vertical\"&gt; &lt;button open-type=\"contact\" class=\"contact\" bindcontact=\"handleContact\"&gt; &lt;image src=\"/img/customer_service.png\" class=\"contact_icon\"&gt;&lt;/image&gt; &lt;/button&gt; &lt;/movable-view&gt;&lt;/movable-area&gt; 修改css样式 12345678910111213141516171819202122232425262728.contact_box&#123; width: 100vw; height: 92vh; position: fixed; &#125;.contact_conten&#123; width: fit-content; height: fit-content; position: fixed; z-index: 9999;&#125;.contact&#123; background: transparent; border-color:transparent; padding-left: 0; padding-right: 0;&#125;.contact::after&#123; border-color:transparent;&#125;.contact .contact_icon&#123; display: inline-block; width: 140rpx; height: 160rpx;&#125; 修改js部分 1234data:&#123; y:wx.getSystemInfoSync().windowHeight, x:wx.getSystemInfoSync().windowWidth&#125; 微信 小程序官方文档说明官方链接","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/categories/微信小程序/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/tags/微信小程序/"}]},{"title":"微信小程序分包","slug":"小程序分包","date":"2020-07-06T06:03:05.000Z","updated":"2020-07-06T06:59:19.654Z","comments":false,"path":"小程序分包/","link":"","permalink":"http://yoursite.com/小程序分包/","excerpt":"因为微信小程序目前限制在2M以内，如果程序安装包超过2M可以通过分包加载，但是分包后整个小程序所有分包大小不能超过16M","text":"因为微信小程序目前限制在2M以内，如果程序安装包超过2M可以通过分包加载，但是分包后整个小程序所有分包大小不能超过16M 具体操作,在 app.json subpackages 字段声明项目分包结构：123456789101112131415161718\"subpackages\": [ &#123; \"root\": \"pages/packageA\", //分包根目录 指定 根目录下的文件夹 \"name\": \"pack1\", //分包别名，分包预下载时可以使用 \"independent\" : false, // 分包是否是独立分包 \"pages\": [ \"pages/cat\", //分包页面路径，相对与分包根目录 \"pages/dog\" ] &#125;, &#123; \"root\": \"packageB\", \"name\": \"pack2\", \"pages\": [ \"pages/apple\", \"pages/banana\" ] &#125;] 打包原则 声明 subpackages 后，将按 subpackages 配置路径进行打包，subpackages 配置路径外的目录将被打包到 app（主包） 中 app（主包）也可以有自己的 pages（即最外层的 pages 字段） subpackage 的根目录不能是另外一个 subpackage 内的子目录 tabBar 页面必须在 app（主包）内 引用原则 packageA 无法 require packageB JS 文件，但可以 require app、自己 package 内的 JS 文件 packageA 无法 import packageB 的 template，但可以 require app、自己 package 内的 template packageA 无法使用 packageB 的资源，但可以使用 app、自己 package 内的资源 独立分包是小程序中一种特殊类型的分包，可以独立于主包和其他分包运行。从独立分包中页面进入小程序时，不需要下载主包。当用户进入普通分包或主包内页面时，主包才会被下载。 开发者可以按需将某些具有一定功能独立性的页面配置到独立分包中。当小程序从普通的分包页面启动时，需要首先下载主包；而独立分包不依赖主包即可运行，可以很大程度上提升分包页面的启动速度。 一个小程序中可以有多个独立分包。 使用独立分包时要注意： 独立分包中不能依赖主包和其他分包中的内容，包括js文件、template、wxss、自定义组件、插件等。主包中的app.wxss对独立分包无效，应避免在独立分包页面中使用 app.wxss 中的样式； App 只能在主包内定义，独立分包中不能定义 App，会造成无法预期的行为； 独立分包中暂时不支持使用插件。关于 getApp()与普通分包不同，独立分包运行时，App 并不一定被注册，因此 getApp() 也不一定可以获得 App 对象： 当用户从独立分包页面启动小程序时，主包不存在，App也不存在，此时调用 getApp() 获取到的是 undefined。 当用户进入普通分包或主包内页面时，主包才会被下载，App 才会被注册。当用户是从普通分包或主包内页面跳转到独立分包页面时，主包已经存在，此时调用 getApp() 可以获取到真正的 App。由于这一限制，开发者无法通过 App 对象实现独立分包和小程序其他部分的全局变量共享。 为了在独立分包中满足这一需求，基础库 2.2.4 版本开始 getApp支持 [allowDefault]参数，在 App 未定义时返回一个默认实现。当主包加载，App 被注册时，默认实现中定义的属性会被覆盖合并到真正的 App 中。 当从独立分包启动小程序时，主包中 App 的 onLaunch 和首次 onShow 会在从独立分包页面首次进入主包或其他普通分包页面时调用。 由于独立分包中无法定义 App，小程序生命周期的监听可以使用 wx.onAppShow，wx.onAppHide 完成。App 上的其他事件可以使用 wx.onError，wx.onPageNotFound 监听 预下载分包行为在进入某个页面时触发，通过在 app.json 增加 preloadRule 配置来控制。 123456789101112131415161718192021222324252627282930313233343536373839404142&#123; \"pages\": [\"pages/index\"], \"subpackages\": [ &#123; \"root\": \"important\", \"pages\": [\"index\"], &#125;, &#123; \"root\": \"sub1\", \"pages\": [\"index\"], &#125;, &#123; \"name\": \"hello\", \"root\": \"path/to\", \"pages\": [\"index\"] &#125;, &#123; \"root\": \"sub3\", \"pages\": [\"index\"] &#125;, &#123; \"root\": \"indep\", \"pages\": [\"index\"], \"independent\": true &#125; ], \"preloadRule\": &#123; \"pages/index\": &#123; \"network\": \"all\", \"packages\": [\"important\"] &#125;, \"sub1/index\": &#123; \"packages\": [\"hello\", \"sub3\"] &#125;, \"sub3/index\": &#123; \"packages\": [\"path/to\"] &#125;, \"indep/index\": &#123; \"packages\": [\"__APP__\"] &#125; &#125;&#125; 限制同一个分包中的页面享有共同的预下载大小限额 2M，限额会在工具中打包时校验。如，页面 A 和 B 都在同一个分包中，A 中预下载总大小 0.5M 的分包，B中最多只能预下载总大小 1.5M 的分包。 原文转至: https://www.cnblogs.com/wen-/p/12109247.html","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/categories/微信小程序/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/tags/微信小程序/"}]},{"title":"Hexo增加搜索功能","slug":"Hexo增加搜索功能","date":"2020-07-06T06:03:05.000Z","updated":"2020-07-06T06:59:23.173Z","comments":false,"path":"Hexo增加搜索功能/","link":"","permalink":"http://yoursite.com/Hexo增加搜索功能/","excerpt":"随着时间的推移，博客文章越来越多。为了方便快速找到文章，增加一个站点内的搜索功能是非常必要的。","text":"随着时间的推移，博客文章越来越多。为了方便快速找到文章，增加一个站点内的搜索功能是非常必要的。 #具体操作：1.安装搜索：在Hexo的根目录下，打开命令可执行窗口，执行如下命令：1npm install hexo-generator-search --save 2.全局配置文件_config.yml，新增如下内容：12345search: path: search.xml field: post format: html limit: 10000 3.hexo主题配置文件（\\themes\\next_config.yml），修改local_search的enable为true：123456789# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"Hexo 多台电脑配置","slug":"Hexo多台电脑配置","date":"2020-03-02T07:16:17.000Z","updated":"2020-07-03T09:01:29.832Z","comments":false,"path":"Hexo多台电脑配置/","link":"","permalink":"http://yoursite.com/Hexo多台电脑配置/","excerpt":"Hexo 多台电脑配置","text":"Hexo 多台电脑配置 在之前的一篇文章中描述了Hexo 加 github搭建怎么从零开始搭建、备份个人博客的文章 今天说一下多台电脑同时配置 hexo 首先确保自己已经使用hexo在github搭建好了自己的个人博客。 对username.github.io仓库 hexo分支拉取到本地;命令如下：1git clone https://github.com/*****/****.github.io.git 此时从github 拉取的代码为 master主分支 这是我们需要切换分支，命令如下：12git chckout hexo//hexo 为切换分支的名称 此时本地会有一个新的hexo项目，但是由于.gitignore文件中过滤了node_modules\\，所以克隆下来的目录里没有node_modules\\，这是hexo所需要的组件，所以要在该目录中重新安装hexo，但不需要hexo init。1234npm install hexonpm install hexo --savenpm installnpm install hexo-deployer-git --save ####新建一篇文章测试1hexo s //本地服务 ####推送到hexo分支123git add .git commit -m \"add work PC test\"git push origin hexo ####部署到master分支1hexo g -d ####日常操作如果上面的过程都操作无误的话，你就可以在任何能联网的电脑上写博客啦。一般写博客的流程是下面这样。 ####写博客前不管你本地的仓库是否是最新的，都先pull一下，以防万一：1git pull origin hexo 写博客hexo new “title”然后打开source/_posts/title.md，撰写博文。 写完博客先推送到hexo分支上：123git add .git commit -m \"add work PC test\"git push origin hexo 最后部署到master分支上1hexo g -d 整个流程大概就是这样。","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"Hexo 错误记录","slug":"hexo错误记录","date":"2020-03-02T07:16:17.000Z","updated":"2020-07-03T09:01:49.469Z","comments":false,"path":"hexo错误记录/","link":"","permalink":"http://yoursite.com/hexo错误记录/","excerpt":"Hexo 错误记录","text":"Hexo 错误记录 大致错误如下:12FATAL Something's wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlTypeError [ERR_INVALID_ARG_TYPE]: The \"mode\" argument must be integer. Receivedan instance of Object 在百度多次搜索、验证，验证找到错误原因为node.js版本太高导致，但是自己又不想卸载原本的nodejs版本，所以在网上找了个叫 nvm 的工具降低 node的版本；接下来就可以 hexo g -d 完美解决此次错误 12Error: ERROR: The key you are authenticating with has been marked as read only.fatal: Could not read from remote repository. .jpg) 在配置ssh key文件时勾选上Allow write access 选项","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"小程序保存海报","slug":"小程序保存海报","date":"2019-10-07T16:00:00.000Z","updated":"2020-07-06T06:56:35.061Z","comments":false,"path":"小程序保存海报/","link":"","permalink":"http://yoursite.com/小程序保存海报/","excerpt":"微信小程序实现用户选择图片实现保存海报功能","text":"微信小程序实现用户选择图片实现保存海报功能 ***.wxml1234567891011121314151617181920212223&lt;view class='friend-layer2'&gt; &lt;view class='invitation_method'&gt;邀请方式2：&lt;/view&gt; &lt;view class='poster_box'&gt; &lt;view class='poster_img_box'&gt; &lt;view class=\"page-section page-section-spacing swiper\"&gt; &lt;swiper current='&#123;&#123;currentInd&#125;&#125;' skip-hidden-item-layout=\"true\" indicator-dots=\"true\" circular=\"true\" indicator-color=\"#E7EAED\" indicator-active-color=\"#FF9310\" bindchange=\"imgChange\"&gt; &lt;block wx:for=\"&#123;&#123;background&#125;&#125;\" wx:key=\"project_type\"&gt; &lt;swiper-item&gt; &lt;view class=\"swiper-item\"&gt; &lt;image src='&#123;&#123;item.image_server_path&#125;&#125;' class=\"bj\"&gt;&lt;/image&gt; &lt;image src=\"&#123;&#123;QRCode&#125;&#125;\" class=\"QRCode\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/swiper-item&gt; &lt;/block&gt; &lt;/swiper&gt; &lt;/view&gt; &lt;/view&gt; &lt;button class='sava_btn' size='mini' bindtap='saveImage'&gt;保存海报&lt;/button&gt; &lt;/view&gt;&lt;/view&gt;&lt;view class=\"myCanvas\"&gt; &lt;canvas class=\"myCanvas\" canvas-id=\"myCanvas\" style=\"width: 750rpx; height: 1334rpx;\"&gt;&lt;/canvas&gt;&lt;/view&gt; ***.wxss 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394.friend-layer2 &#123; padding: 30rpx 40rpx; box-sizing: border-box; position: relative;&#125;.friend-layer2 .poster_box &#123; width: 100%; height: 820rpx; background: rgba(255, 255, 255, 1); border-radius: 12rpx; margin-top: 30rpx; padding: 0rpx 30rpx; box-sizing: border-box; overflow: hidden;&#125;.friend-layer2 .poster_box .title &#123; font-size: 24rpx; font-family: PingFangSC-Regular; font-weight: 400; color: #333; padding: 40rpx 0rpx;&#125;.friend-layer2 .poster_box .poster_img_box &#123; width: 325rpx; height: 562rpx; margin: auto; position: relative;&#125;.friend-layer2 .poster_box .poster_img_box .poster_img_bg &#123; width: 325rpx; height: 562rpx; overflow: hidden;&#125;.friend-layer2 .poster_box .poster_img_box .poster_img_bg image &#123; display: block; width: 100%; height: 100%;&#125;.friend-layer2 .poster_box .swiper &#123; position: absolute; width: 309rpx; height: 546rpx; top: 8rpx; left: 8rpx;&#125;.friend-layer2 .poster_box swiper &#123; width: 100%; height: 100%; /* overflow: hidden; */&#125;.friend-layer2 .poster_box swiper .swiper-item &#123; width: 100%; height: 100%;&#125;.friend-layer2 .poster_box swiper .swiper-item .bj &#123; display: block; width: 100%; height: 100%;&#125;.friend-layer2 .poster_box swiper .swiper-item .QRCode &#123; position: absolute; width: 80rpx; height: 80rpx; display: block; bottom: 55rpx; right: 112rpx;&#125;.friend-layer2 .poster_box .sava_btn &#123; position: relative; left: 50%; transform: translateX(-50%); margin-top: 40rpx;&#125;.myCanvas &#123; position: absolute; left: -1000px;&#125;.sava_btn &#123; background: #ff9310; color: #fff;&#125; **.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266data: &#123; background: [], QRCode: '', //二维码 HeadImg: '', //用户头像 currentInd: 0, //海报默认选中下标 hasSave: false,&#125;, //获取图片getImage: function() &#123; request.wxCheckSess().then(res =&gt; &#123; let url = rurl.serviceAdd + 'freelancer/load-qr-code-and-poster-path'; let data = &#123; project_type: 0 &#125; request.$http(url, data, 'GET').then(res =&gt; &#123; if (res &amp;&amp; res.code == 1000 &amp;&amp; res.data) &#123; this.setData(&#123; background: res.data.posterPath, QRCode: 'data:image/jpeg;base64,' + res.data.base64, //二维码 HeadImg: 'data:image/jpeg;base64,' + res.data.headerBase64 &#125;) &#125; &#125;) &#125;).catch()&#125;,//设置海报二维码、头像宽高setImageWidth() &#123; let currentInd = this.data.currentInd; //海报选中下标 let posterObj = this.data.background[currentInd]; //选中海报 //二维码位置、大小 let image_x = parseFloat(posterObj.image_x) / 2 * multiple; let image_y = parseFloat(posterObj.image_y) / 2 * multiple; let width = parseFloat(posterObj.width) / 2 * multiple; let height = parseFloat(posterObj.height) / 2 * multiple; //头像位置、大小 let header_image_x = parseFloat(posterObj.header_image_x) / 2 * multiple; let header_image_y = parseFloat(posterObj.header_image_y) / 2 * multiple; let header_width = parseFloat(posterObj.header_width) / 2 * multiple; let header_height = parseFloat(posterObj.header_height) / 2 * multiple; //canvas画圆头像半径 、位置 let circle_r = header_height / 2; let circle_x = header_image_x + circle_r; let circle_y = header_image_y + circle_r;&#125;,//海报选中改变了imgChange: function(e) &#123; let currentInd = e.detail.current; this.setData(&#123; currentInd: currentInd &#125;);&#125;,//海报保存saveImage: function() &#123; wx.showLoading(&#123; title: '保存中...', mask: true &#125;) if (this.data.hasSave) &#123; wx.showToast(&#123; title: '请稍后...', icon: 'none', duration: 2000, mask: true &#125;) return &#125; this.setData(&#123; hasSave: true &#125;) wx.getSetting(&#123; success: res =&gt; &#123; console.log(res) console.log(res.authSetting['scope.writePhotosAlbum'], !res.authSetting['scope.writePhotosAlbum']) if (res.authSetting['scope.writePhotosAlbum'] == undefined) &#123; console.log(1) this.save() &#125; else if (res.authSetting['scope.writePhotosAlbum'] == false) &#123; console.log(2) wx.openSetting(&#123; \"scope.writePhotosAlbum\": true &#125;) &#125; else &#123; console.log(3) this.save() &#125; &#125; &#125;)&#125;,save: function() &#123; // 保存到本地 const canvas = wx.createCanvasContext('myCanvas'); let currentInd = this.data.currentInd; //海报选中下标 let posterObj = this.data.background[currentInd]; //选中海报 let _this = this; if (posterObj) &#123; let BjImg = posterObj.image_server_path; let QRCode = this.data.QRCode; let HeadImg = this.data.HeadImg; let multiple = getRatio(); //获取手机屏幕基于苹果7（375px） 的倍数 console.log(multiple) //二维码位置、大小 let image_x = parseFloat(posterObj.image_x) / 2 * multiple; let image_y = parseFloat(posterObj.image_y) / 2 * multiple; let width = parseFloat(posterObj.width) / 2 * multiple; let height = parseFloat(posterObj.height) / 2 * multiple; //头像位置、大小 let header_image_x = parseFloat(posterObj.header_image_x) / 2 * multiple; let header_image_y = parseFloat(posterObj.header_image_y) / 2 * multiple; let header_width = parseFloat(posterObj.header_width) / 2 * multiple; let header_height = parseFloat(posterObj.header_height) / 2 * multiple; //canvas画圆头像半径 、位置 let circle_r = header_height / 2; let circle_x = header_image_x + circle_r; let circle_y = header_image_y + circle_r; //缓存海报背景 wx.getImageInfo(&#123; src: BjImg, success: function(res) &#123; //canvas 绘制海报背景 canvas.drawImage(res.path, 0, 0, res.width / 2 * multiple, res.height / 2 * multiple); //canvas 绘制图片 不支持 base64 图片 //把base64 转换成 图片路径 base64src(QRCode, res =&gt; &#123; //缓存二维码 wx.getImageInfo(&#123; src: res, success: function(data) &#123; canvas.drawImage(data.path, image_x, image_y, width, height); //缓存用户头像 base64src(HeadImg, res =&gt; &#123; wx.getImageInfo(&#123; src: res, success: function(res) &#123; canvas.save(); canvas.beginPath(); console.log(header_image_x, header_image_y, header_width, header_height, 'HeadImg'); console.log(circle_x, circle_y, circle_r, 'circle'); canvas.arc(circle_x, circle_y, circle_r, 0, 2 * Math.PI, false) canvas.clip(); canvas.drawImage(res.path, header_image_x, header_image_y, header_width, header_height); canvas.restore(); canvas.draw(false, () =&gt; &#123; wx.canvasToTempFilePath(&#123; x: 0, y: 0, width: 750, height: 1334, canvasId: 'myCanvas', fileType: 'jpg', success: (res) =&gt; &#123; let pic = res.tempFilePath; wx.saveImageToPhotosAlbum(&#123; filePath: pic, success(res) &#123; request.wxCheckSess().then(res =&gt; &#123; let jwtobj = wx.getStorageSync('jwtobj'); request.getToken().then((jwtobj) =&gt; &#123; wx.uploadFile(&#123; url: rurl.serviceAdd + 'freelancer/upload-poster', //仅为示例，非真实的接口地址 filePath: pic, name: 'file', formData: &#123; project_type: posterObj.project_type &#125;, header: &#123; Authorization: \"Bearer \" + jwtobj.access_token &#125;, success(res) &#123; wx.showToast(&#123; title: '保存成功', icon: 'success', duration: 2000, mask: true &#125;); let Timeout = setTimeout(() =&gt; &#123; _this.setData(&#123; hasSave: false &#125;) clearTimeout(Timeout) &#125;, 2000) &#125;, fail: error =&gt; &#123; wx.hideLoading(); wx.showToast(&#123; title: '保存失败', icon: 'none', duration: 2000, mask: true &#125;); _this.setData(&#123; hasSave: false &#125;) &#125; &#125;) &#125;) &#125;).catch() &#125;, fail: error =&gt; &#123; console.log(error) _this.setData(&#123; hasSave: false &#125;) wx.hideLoading(); wx.showToast(&#123; title: '取消保存', icon: 'none', duration: 2000, mask: true &#125;); &#125; &#125;); &#125;, fail: res =&gt; &#123; console.log(res); wx.hideLoading() &#125; &#125;); &#125;); &#125;, fail: res =&gt; &#123; console.log(res); wx.hideLoading() &#125; &#125;) &#125;) &#125;, fail: res =&gt; &#123; console.log(res); wx.hideLoading() &#125; &#125;) &#125;); &#125;, fail: res =&gt; &#123; console.log(res); wx.hideLoading() &#125; &#125;) // canvas.drawImage(QRCode, image_x, image_y, width, height); &#125;&#125; 效果如下：","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/categories/微信小程序/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/tags/微信小程序/"}]},{"title":"小程序单选、多选样式修改","slug":"小程序单选、多选样式修改","date":"2019-08-09T16:00:00.000Z","updated":"2020-07-06T06:55:10.357Z","comments":false,"path":"小程序单选、多选样式修改/","link":"","permalink":"http://yoursite.com/小程序单选、多选样式修改/","excerpt":"微信小程序单选和多选框样式的修改","text":"微信小程序单选和多选框样式的修改 单选框修改选中后的颜色12345678910111213141516171819202122232425262728/* 重写 radio 样式 *//* 未选中的 背景样式 */radio .wx-radio-input&#123; border-radius: 50%;/* 圆角 */ width: 40rpx; height: 40rpx;&#125;/* 这里如果不能修改背景颜色，在选中后的样式中添加background-color *//* 选中后的 背景样式 （红色背景 无边框 可根据UI需求自己修改） */radio .wx-radio-input.wx-radio-input-checked&#123; border: none; background: #FF903F;&#125;/* 选中后的 对勾样式 （白色对勾 可根据UI需求自己修改） */radio .wx-radio-input.wx-radio-input-checked::before&#123; border-radius: 50%;/* 圆角 */ width: 40rpx; /* 选中后对勾大小，不要超过背景的尺寸 */ height: 40rpx; /* 选中后对勾大小，不要超过背景的尺寸 */ line-height: 40rpx; text-align: center;&#125; #多选框修改选中后样式12345678910111213141516171819202122232425262728/*checkbox 整体大小 */checkbox &#123; width: 60rpx; height: 60rpx; line-height: 60rpx;&#125;/*checkbox 选项框大小 */checkbox .wx-checkbox-input &#123; width: 40rpx; height: 40rpx;&#125;/*checkbox选中后样式 */checkbox .wx-checkbox-input.wx-checkbox-input-checked &#123; background: #0080FF;&#125;/*checkbox选中后图标样式 */checkbox .wx-checkbox-input.wx-checkbox-input-checked::before &#123; width: 40rpx; height: 40rpx; line-height: 40rpx;&#125;","categories":[],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/tags/微信小程序/"}]},{"title":"vue使用swiper实现轮播","slug":"vue使用swiper实现轮播","date":"2019-03-26T06:03:05.000Z","updated":"2020-07-06T06:56:54.404Z","comments":false,"path":"vue使用swiper实现轮播/","link":"","permalink":"http://yoursite.com/vue使用swiper实现轮播/","excerpt":"vue使用swiper实现轮播","text":"vue使用swiper实现轮播swiper官网 #第一步：安装swiper1npm install --save swiper #第二步：写template案例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;template&gt; &lt;div id=\"\"&gt; &lt;div class=\"swiper-container\"&gt; &lt;div class=\"swiper-wrapper\"&gt; &lt;div class=\"swiper-slide\" v-for=\"str in listImg\" :style=\"&#123; backgroundImage: 'url(' + str.url + ')' &#125;\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"swiper-pagination swiper-pagination-white swiper-pagination-clickable swiper-pagination-bullets\"&gt; &lt;span class=\"swiper-pagination-bullet\" v-for=\"str in listImg\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Swiper from 'swiper' import 'swiper/dist/css/swiper.min.css' import a from '../assets/benner/yichihei.jpg' import b from '../assets/benner/yixihei.jpg' export default&#123; mounted() &#123; var mySwiper = new Swiper('.swiper-container',&#123; pagination: &#123;//分页器 el: '.swiper-pagination', type: 'bullets',//分页器样式 clickable :true//是否可以点击 &#125;, loop: true,//无限轮播 speed: 600,//平滑的速度 autoplay:true//自动轮播滑动 &#125;) &#125;, data()&#123; return&#123; listImg:[ &#123;url:a&#125;, &#123;url:b&#125;, &#123;url:a&#125; ] &#125; &#125; &#125;&lt;/script&gt;&lt;style &gt; .swiper-container &#123; width: 100%; height: 10rem; margin-top: 44px; &#125; .swiper-container .swiper-wrapper &#123; width: 100%; height: 100%; &#125; .swiper-slide &#123; background-position: center; background-size: cover; width: 100%; height: 100%; &#125; .swiper-slide img &#123; width: 100%; height: 100%; &#125; .swiper-pagination-bullet &#123; width: 0.833rem; height: 0.833rem; display: inline-block; background: #ff5b06; opacity:1; &#125; &lt;/style&gt;","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"工具","slug":"vue/工具","permalink":"http://yoursite.com/categories/vue/工具/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"swiper","slug":"swiper","permalink":"http://yoursite.com/tags/swiper/"}]},{"title":"vue-cli 3.0","slug":"vue-cli 3.0搭建项目","date":"2019-03-26T06:03:05.000Z","updated":"2020-07-06T06:56:50.821Z","comments":false,"path":"vue-cli 3.0搭建项目/","link":"","permalink":"http://yoursite.com/vue-cli 3.0搭建项目/","excerpt":"vue-cli 3.0搭建项目","text":"vue-cli 3.0搭建项目 #安装全局快速原型设计1npm install -g @vue/cli-service-global #使用以下命令来创建新项目1vue create hello-world 如下图所示： 这个默认的设置非常适合快速创建一个新项目的原型，而手动设置则提供了更多的选项，它们是面向生产的项目更加需要的。 如下图所示： 选择后按回车键 如下图所示： #根目录下新建 vue.config.js 文件123456789101112module.exports = &#123; publicPath: process.env.NODE_ENV === 'production' ? './' : './',//部署应用包时的基础路径 outputDir: 'test',//生产环境构建文件的目录 assetsDir: '',//放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录 indexPath:'index.html',//指定生成的 index.html 的输出路径 (相对于 outputDir)。也可以是一个绝对路径 filenameHashing:true,//生成的静态资源文件名中包含了是否 hash transpileDependencies:[],//如果你想要通过 Babel 显式转译一个依赖，可以在这个选项中列出来 productionSourceMap:false,//是否需要map文件 css:&#123; modules:true,//是否允许css预处理（scss|sass|less|styl）文件 &#125;&#125;","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"vue3.0","slug":"vue/vue3-0","permalink":"http://yoursite.com/categories/vue/vue3-0/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"类库网站、插件整理","slug":"插件整理","date":"2019-03-26T06:03:05.000Z","updated":"2020-07-06T06:56:28.052Z","comments":false,"path":"插件整理/","link":"","permalink":"http://yoursite.com/插件整理/","excerpt":"类库网站、插件整理","text":"类库网站、插件整理下拉加载icon字体h5+vue配置信息vue插件库vue vonic样式APIvue2 样式Api前端资源教程vue三级联动vue完整项目介绍前端组件、插件汇总vue拖动插件vue-slicksort vue拖动插件 vue-grid-layout 栅格布局系统 光环云–大屏项目使用handsontable vue表格控件动画复制粘贴插件vue 滑块验证vuex 页面刷新状态管理数据保存vue滚动条样式优化插件苹果测试平台连接苹果内测平台 获取苹果用户的UDIDlodashlodash 中文版https://aweiu.com/documents/element-ui-verify 内网穿透","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"vue3.0","slug":"vue/vue3-0","permalink":"http://yoursite.com/categories/vue/vue3-0/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"Webpack配置多环境build","slug":"Webpack配置多环境build","date":"2019-01-30T06:03:05.000Z","updated":"2020-07-06T07:30:50.853Z","comments":false,"path":"Webpack配置多环境build/","link":"","permalink":"http://yoursite.com/Webpack配置多环境build/","excerpt":"用vue cli2.0 脚手架搭建的项目，脚手架默认生成 dev.env.js，prod.env.js 两个环境变量声明文件，build时默认使用 prod.env.js ，这不便于我们分别 build 测试环境和 生产环境代码","text":"用vue cli2.0 脚手架搭建的项目，脚手架默认生成 dev.env.js，prod.env.js 两个环境变量声明文件，build时默认使用 prod.env.js ，这不便于我们分别 build 测试环境和 生产环境代码 目前我们的前端项目中使用到Webpack的前提下，在 config 目录下可以看到有 dev.env.js，prod.env.js 两个环境变量声明文件，build时默认使用 prod.env.js ，这不便于我们分别 build 测试环境和 生产环境代码这个声明文件内容大致如下 dev.env.js12345678'use strict'const merge = require('webpack-merge')const prodEnv = require('./prod.env') module.exports = merge(prodEnv, &#123; NODE_ENV: '\"development\"', LOGOUT_URL: '\"http://sso.example.org:9999/logout\"'&#125;) 在其中声明的变量可以在我们的代码中通过 process.env.LOGOUT_URL 来引用：form.action = process.env.LOGOUT_URL在 build 阶段使用哪个 xxx.env.js 的声明即决定了最终build输出内容中变量的值。在此我只做抛砖引玉，通过简单的扩展，添加一个自定义的 xxx.env.js 文件，并通过build命令传参来控制使用哪个文件。 比如我们就缺少一个test环境的配置，具体步骤如下： 1、创建 config/test.env.js123456'use strict'module.exports = merge(prodEnv, &#123; NODE_ENV: '\"test\"', BASE_API: '\"/\"', LOGOUT_URL: '\"http://172.16.0.95/logout\"'&#125;) 2、创建 process-argv.js在 build 目录创建 process-argv.js，内容如下：12const processArgv = process.argv.splice(2)module.exports = processArgv process.argv 用于读取node xxx.js –yyy 命令的传参，比如 –yyy 即参数。但只有第一次使用会得到，再次使用则获取不到，所以单独用一个文件来存储后可多次调用。 3、编辑 build/build.js将 const spinner = ora(&#39;building for production...&#39;)这行改为： 12345const processArgv = require('./process-argv')if (processArgv.indexOf('--test') &gt;= 0) &#123; process.env.NODE_ENV = 'test'&#125;const spinner = ora(`building for $&#123;process.env.NODE_ENV&#125;...`) 4、编辑 build/webpack.prod.conf.js将 const env = require(&#39;../config/prod.env&#39;) 这行改为： 1234567let envName = 'prod'const processArgv = require('./process-argv')if (processArgv.indexOf('--test') &gt;= 0) &#123; envName = 'test'&#125;console.log(`building $&#123;envName&#125;`)const env = require(`../config/$&#123;envName&#125;.env`) 5、package.json 增加命令12345//...\"scripts\": &#123; \"test-build\": \"node build/build.js --test\",&#125;,... 即执行 node build/build.js –test，代表 –test 参数指定了使用 build/test.env.js 作为环境变量声明。不指定时，则默认仍然是prod。","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"vue2.0搭建项目","slug":"vue-cli 2.0搭建项目","date":"2018-05-01T06:03:05.000Z","updated":"2020-07-06T06:56:03.629Z","comments":false,"path":"vue-cli 2.0搭建项目/","link":"","permalink":"http://yoursite.com/vue-cli 2.0搭建项目/","excerpt":"vue2.0搭建项目说明","text":"vue2.0搭建项目说明Vue官网链接Vue安装教程链接 目前vue 已经有了vue 3.0版本了 如需使用vue 2.0旧版本 执行以下命令：1npm install -g @vue/cli-init //获取vue 2.0旧版本 全局安装 vue-cli12npm install vue //最新稳定版npm install --global vue-cli 创建一个基于 webpack 模板的新项目12345678910vue init webpack my-project Project name //项目名称 Project description //项目描述 Author //作者 Vue build //vue的建立 Install vue-router? //安装vue路由 Use ESLint to lint your code？ //该选项为使用ESLint规范你的代码，一个空格错误都将报错，不开启，避免不必要的麻烦 Set up unit tests？ //设置单元测试 Setup e2e tests with Nightwatch // Nightwatch建立端到端的测试 Should we run `npm install` for you after the project has been created? (recommended) (Use arrow keys) //确认创建项目 如下图： 安装依赖，走你1234cd my-project //跳转至my-project文件路径下npm install //初始化webpack模块npm run dev //启动服务器npm install vue-router vue-resource --save //安装路由模块 如下图：","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"vue2.0","slug":"vue/vue2-0","permalink":"http://yoursite.com/categories/vue/vue2-0/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"gulp添加版本功能笔记","slug":"gulp添加版本功能笔记","date":"2018-04-14T00:57:16.000Z","updated":"2020-07-03T09:02:26.135Z","comments":false,"path":"gulp添加版本功能笔记/","link":"","permalink":"http://yoursite.com/gulp添加版本功能笔记/","excerpt":"使用Gulp添加版本功能笔记","text":"使用Gulp添加版本功能笔记 安装gulp和gulp插件12345npm install --save-dev gulpnpm install --save-dev gulp-revnpm install --save-dev gulp-rev-collectornpm install --save-dev gulp-asset-revnpm install --save-dev run-sequence 编写gulpfile.js 此文件包含编译less，压缩、重命名css和js，同时可以压缩html并自动添加版本号的gulp.js配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121//引入gulp和gulp插件var gulp = require('gulp'), less = require('gulp-less'), assetRev = require('gulp-asset-rev'), minifyCss = require('gulp-minify-css'), uglify = require('gulp-uglify'), htmlmin = require('gulp-htmlmin'), rename = require('gulp-rename'), imagemin = require('gulp-imagemin'), runSequence = require('run-sequence'), rev = require('gulp-rev'), revCollector = require('gulp-rev-collector'); //定义css、js源文件路径var cssSrc = 'css/*.css', cssMinSrc = 'dist/css/*.css', jsSrc = 'js/*.js', jsMinSrc = 'dist/js/*.js', lessSrc = 'less/*.less', imgMinSrc = 'dist/images/*.&#123;png,jpg,gif,ico&#125;', htmlSrc = '*.html'; //编译less 定义一个less任务（自定义任务名称）gulp.task('less', function()&#123; return gulp.src(lessSrc) //该任务针对的文件 .pipe(less()) //该任务调用的模块 .pipe(gulp.dest('css'));//编译后的路径&#125;); //为css中引入的图片/字体等添加hash编码gulp.task('assetRev', function()&#123; return gulp.src(cssSrc) //该任务针对的文件 .pipe(assetRev()) //该任务调用的模块 .pipe(gulp.dest('src')); //编译后的路径&#125;); //压缩cssgulp.task('cssMin', function() &#123; return gulp.src(cssSrc) //压缩的文件 .pipe(rename(&#123;suffix: '.min'&#125;)) .pipe(minifyCss()) //执行压缩 .pipe(gulp.dest('dist/css')); //输出文件夹&#125;); //CSS生成文件hash编码并生成 rev-manifest.json文件名对照映射gulp.task('revCss', function()&#123; return gulp.src(cssMinSrc) .pipe(rev()) //文件名加MD5后缀 .pipe(rev.manifest()) //必须有这个方法 生成一个rev-manifest.json .pipe(gulp.dest('dist/css')); //将rev-manifest.json 保存到 dist/css 目录内&#125;); //压缩jsgulp.task('uglify',function()&#123; return gulp.src(jsSrc) .pipe(rename(&#123;suffix: '.min'&#125;)) .pipe(uglify()) .pipe(gulp.dest('dist/js'));&#125;); //js生成文件hash编码并生成 rev-manifest.json文件名对照映射gulp.task('revJs', function()&#123; return gulp.src(jsMinSrc) .pipe(rev()) .pipe(rev.manifest()) .pipe(gulp.dest('dist/js'));&#125;); //压缩htmlgulp.task('htmlMin',function()&#123; var options = &#123; collapseWhitespace:true, //从字面意思应该可以看出来，清除空格，压缩html，这一条比较重要，作用比较大，引起的改变压缩量也特别大。 collapseBooleanAttributes:true, //省略布尔属性的值，比如：&lt;input checked=\"checked\"/&gt;,那么设置这个属性后，就会变成 &lt;input checked/&gt;。 removeComments:true, //清除html中注释的部分，我们应该减少html页面中的注释。 removeEmptyAttributes:true, //清除所有的空属性。 removeScriptTypeAttributes:true, //清除所有script标签中的type=\"text/javascript\"属性。 removeStyleLinkTypeAttributes:true, //清楚所有Link标签上的type属性。 minifyJS:true, //压缩html中的javascript代码。 minifyCSS:true //压缩html中的css代码。 &#125;; return gulp.src(htmlSrc) .pipe(htmlmin(options)) .pipe(gulp.dest('dist/html'));&#125;); //Html替换css、js文件版本gulp.task('revHtml', function () &#123; return gulp.src(['dist/**/*.json', 'dist/html/*.html']) .pipe(revCollector()) .pipe(gulp.dest('dist/html'));&#125;); //压缩imagegulp.task('imageMin', function () &#123; gulp.src('images/*.&#123;png,jpg,gif,ico&#125;') .pipe(imagemin()) .pipe(gulp.dest('dist/images'));&#125;); gulp.task('revImage', function()&#123; return gulp.src(imgMinSrc) .pipe(rev()) .pipe(rev.manifest()) //必须有这个方法 .pipe(gulp.dest('dist/images'));&#125;); gulp.task('default', function (done) &#123; //condition = false; runSequence( //此处不能用gulp.run这个最大限度并行(异步)执行的方法，要用到runSequence这个串行方法(顺序执行)才可以在运行gulp后顺序执行这些任务并在html中加入版本号 'less', 'assetRev', 'cssMin', 'revCss', 'uglify', 'revJs', 'imageMin', 'revImage', 'htmlMin', 'revHtml', done);&#125;); 修改配置文件更改gulp-rev和gulp-rev-collector 打开node_modules\\gulp-rev\\index.js 第144行 manifest[originalFile] = revisionedFile; 更新为: manifest[originalFile] = originalFile + ‘?v=’ + file.revHash;打开nodemodules\\gulp-rev\\nodemodules\\rev-path\\index.js 10行 return filename + ‘-‘ + hash + ext; 更新为: return filename + ext;打开node_modules\\gulp-rev-collector\\index.js 31行 if ( !.isString(json[key]) || path.basename(json[key]).replace(new RegExp( opts.revSuffix ), ‘’ ) !== path.basename(key) ) { 更新为: if ( !.isString(json[key]) || path.basename(json[key]).split(‘?’)[0] !== path.basename(key) ) {打开node_modules\\gulp-assets-rev\\index.js 78行 var verStr = (options.verConnecter || “-“) + md5; 更新为：var verStr = (options.verConnecter || “”) + md5; 80行 src = src.replace(verStr, ‘’).replace(/(.[^.]+)$/, verStr + “$1”); 更新为：src=src+”?v=”+verStr; 继续更改gulp-rev-collector打开node_modules\\gulp-rev-collector\\index.js 第107行 regexp: new RegExp( ‘([\\/\\\\\\’”])’ + pattern, ‘g’ ), 更新为: regexp: new RegExp( ‘([\\/\\\\\\’”])’ + pattern+’(\\?v=\\w{10})?’, ‘g’ ),","categories":[{"name":"打包工具","slug":"打包工具","permalink":"http://yoursite.com/categories/打包工具/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://yoursite.com/tags/gulp/"}]},{"title":"Glup学习笔记","slug":"Glup学习笔记","date":"2018-03-02T07:16:17.000Z","updated":"2020-07-03T09:02:42.119Z","comments":false,"path":"Glup学习笔记/","link":"","permalink":"http://yoursite.com/Glup学习笔记/","excerpt":"使用Gulp打包压缩Html、Css、Js","text":"使用Gulp打包压缩Html、Css、Js node.js 安装 淘宝镜像的安装：npm install -g cnpm –registry=https://registry.npm.taobao.org 全局安装gulp:cnpm install –global gulp 项目安装gulp:cnpm install –save-dev gulp 初始化一个package.json文件：gulp init 然后执行:cnpm install gulp –save-dev 项目安装gulp插件如编译less文件:cnpm install –save-dev gulp-less （less编译）123456789cnpm install --save-dev gulp-sass （sass编译）cnpm install --save-dev gulp-uglify （JS压缩）cnpm install --save-dev gulp-minify-html（html压缩）cnpm install --save-dev gulp-concat （js文件合并）cnpm install –-save-dev gulp-imagemin （图片压缩）cnpm install --save-dev gulp-babel (es6语法)npm install --save-dev gulp-babel babel-preset-env (es6语法)cnpm install --save-dev babel-preset-es2015 (es6转换es5)cnpm install --save-dev gulp-connect (自动刷新) 删除安装的外挂： 首先在全局安装npm i -g rimraf；然后转到你的根目录输入 rimraf -rf node_modules/package(package 依旧是外挂名字 比如 gulp-less);","categories":[{"name":"打包工具","slug":"打包工具","permalink":"http://yoursite.com/categories/打包工具/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://yoursite.com/tags/gulp/"}]},{"title":"MarkDown语法学习笔记","slug":"MarkDown语法学习笔记","date":"2018-02-28T06:03:05.000Z","updated":"2020-07-06T06:55:59.701Z","comments":false,"path":"MarkDown语法学习笔记/","link":"","permalink":"http://yoursite.com/MarkDown语法学习笔记/","excerpt":"关于Markdown的使用手册","text":"关于Markdown的使用手册 标题 用#标记 在 标题开头 加上1~6个#，依次代表一级标题、二级标题….六级标题#一级标题 ##二级标题###三级标题#####四级标题######五级标题######六级标题 用=和-标记 在 标题底下 加上任意个=代表一级标题，-代表二级标题 This is an H1 =============This is an H2 ————- 列表1.无序列表：在文字前加上 *、-或+即可变成无序列表 *red +blue -green 2.有序列表：在文字前加上1.2.3.即可变成有序列表 red blue green 注：符号和文字之间加上一个字符的空格 引用引用以&gt;来表示，引用中支持多级引用、标题、列表、代码块、分割线等常规语法。 这是一段引用 //在&gt;后面有 1 个空格 这是引用的代码块形式 //在`&gt;`后面有 5 个空格 代码例子： protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } 一级引用 二级引用 三级引用 分割线在一行中用三个以上的*、-、_来建立一个分隔线 强调两个或_代表加粗，一个或-代表斜体，~~代表删除 加粗文本 或者 加粗斜体 或者 _斜体_删除注：前后都需要添加 #图片与链接 图片为:1![Alt text](/path/to/img.jpg &quot;Optional title&quot;) Alt text 为如果图片无法显示时显示的文字 /path/to/img.jpg 为图片所在路径 路径可以使用绝对路径也可以使用相对路径，建议使用绝对路径 Optional title 显示标题。显示效果为在你将鼠标放到图片上后，会显示一个小框提示，提示内容就是Option title 里的内容 迁入HTML代码 123456&lt;img scr=&quot;./xxx.png&quot; width = &quot;300&quot; height = &quot;200&quot; alt = &quot;图片名称&quot; align = center /&gt;*&lt;div align=&quot;center&quot;&gt; &lt;img/&gt;&lt;/div&gt; 链接为： 1[]() 换行1&lt;br&gt;","categories":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/categories/笔记/"}],"tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://yoursite.com/tags/MarkDown/"}]},{"title":"Hexo+github搭建博客笔记","slug":"Hexo-github搭建博客笔记","date":"2018-02-28T03:48:43.000Z","updated":"2020-07-03T09:02:14.598Z","comments":false,"path":"Hexo-github搭建博客笔记/","link":"","permalink":"http://yoursite.com/Hexo-github搭建博客笔记/","excerpt":"基于Hexo和github搭建的个人博客，安装过程及问题在此做的不定期整理，并会随时上传至github平台","text":"基于Hexo和github搭建的个人博客，安装过程及问题在此做的不定期整理，并会随时上传至github平台 #安装Nodenode官网下载 根据自己的Windows版本选择相应的安装文件，要是不知道，就安装32-bit的吧。如图： 保持默认设置即可，一路Next，安装很快就结束了。 然后我们检查一下是不是要求的组件都安装好了，同时按下Win和R，打开运行窗口。如图： 在新打开的窗口中输入cmd，敲击回车，打开命令行界面。（下文将直接用打开命令行来表示以上操作，记住哦~） 在打开的命令行界面中，输入：12node -vnpm -v 如果结果如下图所示，则说明安装正确，可以进行下一步了，如果不正确，则需要回头检查自己的安装过程。 #安装GitGit官网下载 和Node.js一样，设置都只需要保持默认 打开命令行，输入git –version检查是否安装正确,如图： github账户的注册和配置 登录进github GitHub官网 创建代码库登陆之后，点击页面右上角的加号，选择New repository 如图：进入代码库创建页面：在Repository name下填写 yourname.github.io 如图： 注意：比如我的github名称是qq785478075 ,这里你就填 qq785478075.github.io,如果你的名字是xujun，那你就填 xujun.github.io 安装Hexo 安装Hexo——确保电脑已经安装Node.js以及Git环境 命令行在git bash下输入 命令行输入： 12$ npm install -g hexo-cli #全局安装$ npm install hexo --save 查看是否安装成功 1$ hexo -v Hexo相关配置 123$ hexo init #初始化hexo$ npm install #安装所需要的组件(生成器)$ hexo s #运行 配置Hexo 配置身份信息 123$ git config -- golbal user.name \"yourname\"$ git config -- golbal user.email \"youremail\"$ ssh-keygen -t rsa -C \"youremail\" #生成密钥，密钥位置会给出提示 id_rsa.pub 配置身份信息 12345deploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch；master注：这里的repo中填写的是SSH-Key 连接代码库登录Github，点击头像下的settings，添加ssh 新建一个new ssh key，将id_rsa.pub文件里的内容复制上去 输入 ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了 在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git –save 使用编辑器编好文章，那么就可以使用命令：hexo d -g，生成以及部署了 假如ssh-key配置失败，那么只要以下步骤就能完全解决首先，清除所有的key-pairssh-add -Drm -r ~/.ssh删除你在github中的public-key重新生成ssh密钥对ssh-keygen -t rsa -C “xxx@xxx.com“ 备份分支源文件123456//git 文件添加git add .//git 提交git commit -m \"init\"//push到hexo分支git push origin hexo","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]}